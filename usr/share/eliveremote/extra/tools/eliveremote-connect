#!/bin/bash
source /usr/lib/elive-tools/functions


# Usage
usage(){
    echo -e "\n$(basename $0) [OPTIONS]"
    cat <<'EOF'

Options:
  -p, --port        set the port to use
  -c, --connect     connect to remove
  -d, --disconnect  disconnect the remote
EOF
    exit
}

do_connect(){
    el_check_variables "port"

    el_explain 0 "note: 'Connection refused' can mean that the password is not set in the remote"
    el_explain 0 "to copy files use: __scp -P $port root@localhost:/tmp__"

    # if we can't directly connect, wait and connect
    if ! ssh -p ${port} root@localhost ; then
        while true
        do
            echo "waiting..."
            if sudo tail -40 /var/log/auth.log | grep -q eliveremote ; then
                # remote should be ready, connect now
                ssh -p ${port} root@localhost

                break
            fi
            sleep 2
        done
    fi

    # disconnect
    do_disconnect

}

do_disconnect(){
    el_check_variables "port"
    # get the pid of the listening process and eject it
    pid_connection="$( sudo netstat -puta | grep "localhost:${port}" | grep -v "^tcp6" | tr ' ' '\n' | grep "/sshd:" | sed 's|/sshd:.*$||g' | sort -u | head -1  )"

    if [[ -n "$pid_connection" ]] ; then
        echo "killing connection with pid: $pid_connection"
        sudo kill "${pid_connection}"
    fi
}


main(){
    # pre {{{
    local var port arg do_connect do_disconnect

    # Usage
    if [[ -z "${1}" ]] ; then
        echo -e "Usage: $(basename $BASH_SOURCE) option, where:"
        echo -e "-c --connect"
        echo -e "-d --disconnect"
        echo -e "-p --port"
        exit 1
    fi

    # copy the tool to the home of the user
    if [[ ! -x "${HOME}/bin/$(basename $0)" ]] ; then
        mkdir -p "${HOME}/bin"
        if [[ "${0}" != "/"* ]] && [[ "${0}" != ../* ]] ; then
            ln -s "$(pwd)/$(basename $0)" "${HOME}/bin/$(basename $0)"
        else
            ln -s "$0" "${HOME}/bin/$(basename $0)"
        fi
    fi


    # }}}
    # args {{{

    # option string, for short options.
    # very much like getopts, any option followed by a ':' takes a required arg
    optstring=p:hcd

    # iterate over options, breaking -ab into -a -b and --foo=bar into --foo bar
    # also turns -- into --endopts to avoid issues with things like '-o-', the '-'
    # should not indicate the end of options, but be an invalid option (or the
    # argument to the option, such as wget -qO-)
    unset options
    while (($#)); do
        case $1 in
            # if option is of type -ab
            -[!-]?*)
            # loop over each character starting with the second
            for ((i=1; i<${#1}; i++)); do
                c=${1:i:1}

                # add current char to options
                options+=("-$c")

                # if option takes a required argument, and it's not the last char
                # make the rest of the string its argument
                if [[ $optstring = *"$c:"* && ${1:i+1} ]]; then
                    options+=("${1:i+1}")
                    break
                fi
            done
            ;;
            # if option is of type --foo=bar, split on first '='
            --?*=*) options+=("${1%%=*}" "${1#*=}");;
            # add --endopts for --
            --) options+=(--endopts);;
            # otherwise, nothing special
            *) options+=("$1");;
        esac

        shift
    done
    # set new positional parameters to altered options
    set -- "${options[@]}"
    unset options

    # actually parse the options and do stuff
    while [[ $1 = -?* ]]; do
        case $1 in
            -h|--help)
                usage >&2; exit 0
                ;;
            -p|--port)
                port="$2"
                shift 2
                ;;
            -c|--connect)
                do_connect=1
                ;;
            -d|--disconnect)
                do_disconnect=1
                ;;
            --endopts) shift; break
                ;;
            *) echo "invalid option: $1" 1>&2 ; exit
                ;;
        esac

        shift
    done



    # - args }}}

    : ${port="2048"}

    if ((do_connect)) ; then
        do_connect
    fi

    if ((do_disconnect)) ; then
        do_disconnect
    fi

}

#
#  MAIN
#
main "$@"

# vim: set foldmethod=marker :
